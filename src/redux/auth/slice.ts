import { createSlice, isAnyOf, PayloadAction } from "@reduxjs/toolkit";
import { register, logIn, logOut, refreshUser, UserRefreshToken,  resetPassword, sendResetEmail, setAuthHeader } from "./operations";
import { REHYDRATE } from "redux-persist/es/constants";
import { Action } from '@reduxjs/toolkit';
import { PersistedState } from 'redux-persist'; // –∞–±–æ –≤–∞—à —Ç–∏–ø –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ–≥–æ —Å—Ç–∞–Ω—É

export interface AuthResponse {
  data: {
  accessToken: string;
  user: {
    name: string;
    email: string;
  };}
}

export interface User {
  id?: string; // id –Ω–µ –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π
  name: string;
  email: string;
}


export interface AuthState {
  user?: User | null;
  token: string | null;
  accessToken: string | null;
  isLoggedIn: boolean;
  isRefreshing: boolean;
  isError: boolean | string;
  isLoading: boolean;
}

const initialState: AuthState = {
  user: null,
  token: null,
  accessToken: null,
  isLoggedIn: false,
  isRefreshing: false,
  isError: false,
  isLoading: false,
};

type AuthStateRehydrate = {
  accessToken: string | null;
  user: { name: string; email: string } | null;
  isLoggedIn: boolean;
};


const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    loginSuccess: (state: AuthState, action: PayloadAction<{ accessToken: string; user: User }>) => {
      console.log("üü¢ LOGIN SUCCESS REDUCER TRIGGERED", action.payload);

      state.accessToken = action.payload.accessToken;
      state.isLoggedIn = true;
      state.user = action.payload.user;

      // üîπ –ó–∞–ø–∏—Å—É—î–º–æ –≤ LocalStorage
      localStorage.setItem("jwt-token", action.payload.accessToken);
      console.log("‚úÖ Token set in Redux & LocalStorage:", state.accessToken);
    },
    setToken: (state, action: PayloadAction<{ accessToken: string; user?: User | null }>) => {
  console.log("üîÑ setToken action received:", action.payload);
  
  if (action.payload.accessToken) {
    state.accessToken = action.payload.accessToken;
    state.isLoggedIn = true; // ‚úÖ –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ isLoggedIn
    console.log("‚úÖ New accessToken - Token –∑–∞–ø–∏—Å–∞–Ω–∏–π —É Redux:", state.accessToken);
    console.log("‚úÖ isLoggedIn –≤ setToken (falce/true):", state.isLoggedIn);
  } else {
    console.warn("‚ö†Ô∏è No accessToken provided in setToken!");
  }

  if (action.payload.user) {
    state.user = action.payload.user;
  } else {
    state.user = null;
  }
},
    logOut: (state) => {
  state.accessToken = null;
  state.isLoggedIn = false;  // ‚úÖ –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ, —â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –ù–ï –∑–∞–ª–æ–≥—ñ–Ω–µ–Ω–∏–π
  state.user = null; 
  localStorage.removeItem("jwt-token"); // ‚úÖ –í–∏–¥–∞–ª—è—î–º–æ —Ç–æ–∫–µ–Ω –∑ localStorage
   },
  },
  extraReducers: (builder) => {
    builder
      // **–ê–¥–∫–µ–π—Å –†–µ–≥—ñ—Å—Ç—Ä–∞—Ü—ñ—è  .addCase(register.fulfilled, **
      .addCase(register.fulfilled, (state, action: PayloadAction<{ status: number; data: AuthResponse }>) => {
        console.log("REGISTER SUCCESS:", action.payload);
        console.log("üü¢ Expected `accessToken`:", action.payload?.data?.data?.accessToken);
     
        state.user = {
          name: action.payload.data.data.user.name,
          email: action.payload.data.data.user.email,
        };

        const accessToken = action.payload?.data?.data?.accessToken;

        if (accessToken) {
          state.accessToken = action.payload.data.data.accessToken;
          localStorage.setItem("jwt-token", action.payload.data.data.accessToken);

          // –í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ –¥–ª—è –≤—Å—ñ—Ö –Ω–∞—Å—Ç—É–ø–Ω–∏—Ö –∑–∞–ø–∏—Ç—ñ–≤
          setAuthHeader(action.payload.data.data.accessToken);
        } else {
          console.warn("‚ö†Ô∏è Register response does not contain accessToken!");
        }
        state.isLoggedIn = true;
        state.isLoading = false;
      })

      // **–ê–¥–∫–µ–π—Å –õ–æ–≥—ñ–Ω .addCase(logIn.fulfilled, **
      
      .addCase(logIn.fulfilled, (state, action: PayloadAction<{ status: number; data: AuthResponse }>) => {
        console.log("üü¢ logIn.fulfilled TRIGGERED!");
        console.log("üîë Payload –æ—Ç—Ä–∏–º–∞–Ω–æ:", action.payload);
        console.log("üìå –û—Ç—Ä–∏–º–∞–Ω–æ —Ç–æ–∫–µ–Ω:", action.payload?.data?.data?.accessToken);

        state.user = {
          name: action.payload.data.data.user.name,
          email: action.payload.data.data.user.email,
        };

        state.accessToken = action.payload.data.data.accessToken;
        state.isLoggedIn = true;
        localStorage.setItem("jwt-token", action.payload.data.data.accessToken);
        setAuthHeader(action.payload.data.data.accessToken);

        console.log("‚úÖ Token —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–æ –≤ Redux:", state.accessToken);
        console.log("‚úÖ isLoggedIn SET TO TRUE in Redux:", state.isLoggedIn);
        console.log("üìå New Redux State:", state); // ‚úÖ –î–æ–¥–∞–ª–∏ –ª–æ–≥ —Å—Ç–∞–Ω—É
      })

      // **–ê–¥–∫–µ–π—Å –õ–æ–≥–∞—É—Ç .addCase(logOut.fulfilled, (–≤–∏—Ö—ñ–¥ –∑ –¥–æ–¥–∞—Ç–∫–∞ –Ω–∞ –ø–æ—Ç–æ—á–Ω—ñ–π —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ)**
      .addCase(logOut.fulfilled, () => initialState)
      .addCase(refreshUser.pending, (state) => {
        state.isRefreshing = true;
      })

      // **–ê–¥–∫–µ–π—Å –†–µ—Ñ—Ä–µ—à .addCase(refreshUser. (–∑–∞–º—ñ–Ω–∞ accessToken –ø—Ä–∏ –ø–æ—Ç—Ä–µ–±—ñ )**
      .addCase(refreshUser.fulfilled, (state, action: PayloadAction<UserRefreshToken>) => {
        console.log("üü¢ REFRESH SUCCESS:", action.payload);

        state.user = {
          id: action.payload.id,
          name: action.payload.name,
          email: action.payload.email,
        };

        if (action.payload.accessToken) {
          state.accessToken = action.payload.accessToken; // üî• –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –Ω–æ–≤–∏–π —Ç–æ–∫–µ–Ω –≤ Redux
          localStorage.setItem("jwt-token", action.payload.accessToken);
        } else {
          console.warn("‚ö†Ô∏è Refresh response does not contain accessToken!");
        }

        state.isRefreshing = false;
        state.isLoggedIn = true;
      })

      .addCase(refreshUser.rejected, (state) => {
        state.isRefreshing = false;
        state.isLoggedIn = false;
      })
      // ** –ê–¥–∫–µ–π—Å .addCase(sendResetEmail.pending, - –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–∞—Ä–æ–ª—è —á–µ—Ä–µ–∑ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è –ª–∏—Å—Ç–∞**
      .addCase(sendResetEmail.pending, (state) => {
        state.isLoading = true;
        state.isError = false;
      })
      .addCase(sendResetEmail.fulfilled, (state) => {
        state.isLoading = false;
      })
      .addCase(sendResetEmail.rejected, (state, action) => {
        state.isLoading = false;
        state.isError = action.payload as string;
      })

      // ** –ê–¥–∫–µ–π—Å .addCase(resetPassword. –°–∫–∏–¥–∞–Ω–Ω—è –ø–∞—Ä–æ–ª—è (–∑–∞–º—ñ–Ω–∞ –ø–∞—Ä–æ–ª—è —á–µ—Ä–µ–∑ —Ç–æ–∫–µ–Ω, –æ—Ç—Ä–∏–º–∞–Ω–∏–π –∑ –ª–∏—Å—Ç–æ–º –Ω–∞ –ø–æ—à—Ç—É)**
      .addCase(resetPassword.pending, (state) => {
        state.isLoading = true;
        state.isError = false;
      })
      .addCase(resetPassword.fulfilled, (state) => {
        state.isLoading = false;
      })
      .addCase(resetPassword.rejected, (state, action) => {
        state.isLoading = false;
        state.isError = action.payload as string;
      })
       .addCase(REHYDRATE, (state, action: Action<"persist/REHYDRATE">) => {
      // –Ø–∫—â–æ payload —ñ—Å–Ω—É—î, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –π–æ–≥–æ —Ç–∏–ø —ñ –ø—Ä–∞—Ü—é—î–º–æ –∑ –Ω–∏–º
      if ((action as any).payload) {
         const payload = (action as any).payload as { auth: AuthStateRehydrate };
        state.accessToken = payload.auth?.accessToken ?? null;
        state.user = payload.auth?.user ?? null;
        state.isLoggedIn = !!payload.auth?.isLoggedIn;
        }
    })

      .addMatcher(isAnyOf(register.pending, logIn.pending), (state) => {
        state.isLoading = true;
      })
      .addMatcher(isAnyOf(register.rejected, logIn.rejected), (state, action: PayloadAction<unknown>) => {
        console.log("LOGIN ERROR:", action.payload); // –î–û–î–ê—é –õ–û–ì —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —á–∏ –∫–æ—Ä–µ–∫—Ç–Ω–æ –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –ø–æ–º–∏–ª–∫–∞ –∑ unwrap()
        state.isLoading = false;
        state.isLoggedIn = false; // –û–ë–û–í'–Ø–ó–ö–û–í–û! –©–æ–± –∫–æ—Ä–µ–∫—Ç–Ω–æ –∑—á–∏—Ç—É–≤–∞–ª–æ—Å—è –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä—ñ
        state.isError = typeof action.payload === "string" ? action.payload : "Unknown error";
      });
    
  },
});

export const { loginSuccess, setToken } = authSlice.actions;
export const authReducer = authSlice.reducer;
export default authSlice.reducer;



// üìå –£ –≤–∫–ª–∞–¥—Ü—ñ Redux DevTools ‚Üí Actions –∑–Ω–∞–π–¥—ñ—Ç—å logIn/fulfilled.

// 1Ô∏è‚É£ –í—ñ–¥–∫—Ä–∏–π—Ç–µ –π–æ–≥–æ —Ç–∞ –ø–æ–¥–∏–≤—ñ—Ç—å—Å—è, —á–∏ —î payload.data.data.accessToken.
// 2Ô∏è‚É£ –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—å, —â–æ –≤ state.auth –∑–º—ñ–Ω—é—î—Ç—å—Å—è isLoggedIn: true.

// ‚û°Ô∏è –Ø–∫—â–æ —Ç–æ–∫–µ–Ω —É payload —î, –∞–ª–µ Redux –Ω–µ –æ–Ω–æ–≤–ª—é—î isLoggedIn, –∑–Ω–∞—á–∏—Ç—å, –ø—Ä–æ–±–ª–µ–º–∞ —É persistReducer –∞–±–æ setToken.